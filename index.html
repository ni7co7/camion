<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Background with 3D Truck</title>
    <style>
      html, body {
        height: 100%;
      
        margin: 0;
        overflow: hidden;
      }
      body {
       /*  background: linear-gradient(120deg, #004d99, #00ff88); */
      /*  background: linear-gradient(120deg, #151515, #0e1f17); */
     
      }
      #c {
         width: 100%; 
       height: 100%;
        display: block;
       
     
       /*   background: linear-gradient(120deg, #004d99, #00ff88);  */
        /*  background: transparent; */ 
        background-color: #cfaeae;
         
      }
      #loading img {
        width: 400px;
      }
      #loading h1 {
        font-weight: bolder;
        font-size: 4.3rem;
       /*  background: linear-gradient(10deg, #0011ff, #ffffff); */
       /*      -webkit-background-clip: text; */
       /*      -webkit-text-fill-color: transparent; */
        color: #0011ff;
       
      }
      #loading span{
      /*   background: linear-gradient(-160deg, #ffffff, #ec0404); */
      /*       -webkit-background-clip: text; */
      /*       -webkit-text-fill-color: transparent; */
       color: #ffffff;
       font-size: 5rem;
       font-style: oblique;
       text-transform: lowercase;
       text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
      }
     /*  #loading h3 { */
     /*    font-size: 1.3rem; */
     /*    color: #ffffff; */
     /*    text-transform: lowercase; */
     /*    letter-spacing: .4rem; */
     /*  } */
      #titulo {
       display: flex;
       flex-direction: column;
       align-items: center;
       justify-content: center;
      }
      #subtitulo  {
        padding: 5%;
        position: fixed;
        filter:blur(0);
        margin: 5%;
        z-index: 2;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: rgb(255, 255, 255);
        font-size: 2.9rem;
        color: #6d1515;
        text-align: center;
      }
      #subtitulo h4{
        text-align: center;
        font-size: 4.3rem;
        color: #2d1991;
        text-shadow: 0 0 10px rgba(108, 56, 56, 0.8);
      }
    </style>
  </head>
  <body>
    <div id="loading" style="
 position: fixed; 
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgb(0, 0, 0);
 /*  color: white; */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  /* font-size: 2rem; */
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  z-index: 1;
">
<div id="titulo">
  <img src="/logo.jpg" alt="logo" width="20">
  <h1>BO<span>FFA</span></h1>
</div>
 <!--  <br> -->
  
  <div id="subtitulo" >
   
    <h6>
        repuestos automotor | rurales | electrónica | textil | química | gráfica | documentos | trámites | pagos | despachos a otras provincias
    </h6>
    <h4>Cargando...</h4> 
  </div>
      
      
</div>
      <h1 id="texto"></h1>
      <script>
        // Mostrar texto "Cargando" al inicio y ocultarlo después de 6 segundos
        setTimeout(() => {
          document.getElementById("loading").style.display = "none";
         
         
        }, 5000);
        setTimeout(() => {
         
          document.getElementById("titulo").style. filter="blur(10px)" ;
         
        }, 2000);
        
      </script>
    
      <script>
        setTimeout(() => {
          document.getElementById("subtitulo").style.display = "block";
        }, 3000);
      </script>
    
    <h1 id="texto"></h1>
    <!-- <img src="/logo.jpg" alt="logo" width="20"> -->
    <script>
      // Definir ciudades
      const ciudad1 = "Río Tercero";
      const ciudad2 = "Córdoba Capital";
      // Mostrar en HTML
/*       document.getElementById("texto").textContent = `${ciudad1} | ${ciudad2}`;
 */    </script>
    <canvas id="c"></canvas>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.1/build/three.module.js"
         
          "three/addons/": "https://threejs.org/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { FontLoader } from 'three/addons/loaders/FontLoader.js';
      import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

      function main() {
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          canvas,
          alpha: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        // Habilitar las sombras en el renderer
       /*  renderer.shadowMap.enabled = true; */
       /*  renderer.shadowMap.type = THREE.PCFSoftShadowMap; */

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.5, 100);
        camera.position.set(10, 15, 29);
        

        const controls = new OrbitControls(camera, canvas);
        controls.enableDamping = true;
        controls.dampingFactor = .05;
        controls.enableZoom = true;
        controls.enableRotate = true;

        controls.enablePan = true;  // Permite mover la cámara en X e Y
        controls.minDistance = 10;   // Distancia mínima del zoom
        controls.maxDistance = 30;  // Distancia máxima del zoom
    /*     controls.maxPolarAngle = Math.PI / 2; // Limita la rotación vertical */
    /*      */

        const scene = new THREE.Scene();
       /*  scene.fog = new THREE.FogExp2( 0xcccccc, 0.011 ); */
        /*  scene.fog = new THREE.Fog( 0xcccccc, 25, 28 ); */ 


        // Reducir la luz ambiental para hacerlo más oscuro
     /*   /*  const ambientLight = new THREE.HemisphereLight( 0x000000, 1);  */// Luz ambiental tenue */
      const ambientLight = new THREE.HemisphereLight( 0xffffff, 100);  // Luz ambiental tenue */
        ambientLight.position.set(0, 20, 0);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 100);
        pointLight.position.set(0, 20, 0);
        scene.add(pointLight);

        // Crear una luz direccional para iluminar el camión
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, -7); // Ajusta la posición de la luz
        directionalLight.castShadow = true; // Habilitar sombras
        scene.add(directionalLight);

          // Crear una luz direccional para iluminar ciudad2
         const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1);
         directionalLight.position.set(-5, -10, 7); // Ajusta la posición de la luz
         directionalLight.castShadow = true; // Habilitar sombras
         scene.add(directionalLight2);

         
        // Crear el camión
        const loader = new GLTFLoader();
        let truck;
        
        loader.load('./van/scene.gltf', function (gltf) {
          truck = gltf.scene;
          truck.scale.set(1, 1, 1);
          truck.position.set(10, 0, 23);
          truck.rotation.y = -2;

          // Habilitar sombras en el camión
          truck.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;  // El camión proyecta sombras
              child.receiveShadow = true;  // El camión recibe sombras
            }
            
          });

          scene.add(truck);
        }, undefined, function (error) {
          console.error('Error al cargar el modelo:', error);
        });

       /*  // Crear ciudad */
       /*     const loaderciudad = new GLTFLoader(); */
       /*     let ciudad; */
       /*     loader.load('./buildings_front/scene.gltf', function (gltf) { */
       /*     ciudad = gltf.scene; */
       /*     ciudad.scale.set(.1, .1, .1); */
       /*     ciudad.position.set(0, 0, 18); */
       /*     ciudad.rotation.y = 360; */
       /*    /*  <ciudad class="innerHtml">cordoba</ciudad> */ 
       /*    /*  innerHtml='asdasda'; */ 
       /*     // Habilitar sombras en el camión */
       /*     ciudad.traverse((child) => { */
       /*       if (child.isMesh) { */
       /*         child.castShadow = true;  // El ciudad proyecta sombras */
       /*         child.receiveShadow = true;  // El ciudad recibe sombras */
       /*       } */
       /*        }); */
       /*    scene.add(ciudad); */
       /*  }, undefined, function (error) { */
       /*    console.error('Error al cargar el modelo:', error); */
       /*  }); */

         // Crear ciudad 2
           const loaderciudad2 = new GLTFLoader();
           let ciudad2;
           loader.load('./buildings_front/scene.gltf', function (gltf) {
           ciudad2 = gltf.scene;
           ciudad2.scale.set(.2, .2, .2);
           ciudad2.position.set(-19, 0, -20);
           ciudad2.rotation.y = -180;
           // Habilitar sombras en el camión
           ciudad2.traverse((child) => {
             if (child.isMesh) {
               child.castShadow = true;  // El ciudad proyecta sombras
               child.receiveShadow = true;  // El ciudad recibe sombras
             }
              });
          scene.add(ciudad2);
        }, undefined, function (error) {
          console.error('Error al cargar el modelo:', error);
        });



     /*    // Crear el grid que recibirá las sombras */
     /*    const gridHelper = new THREE.GridHelper(50, 50); */
     /*     */
     /*    gridHelper.rotation.y = 0; */
     /*     */
     /*    gridHelper.receiveShadow = true; // El grid recibe sombras */
     /*    scene.add(gridHelper); */




      // Cargar las texturas de carretera y pasto
    const textureLoader = new THREE.TextureLoader();
    const roadTexture = textureLoader.load('/paviment.png');
    const grassTexture = textureLoader.load('/grass.jpg');
    const rutaTexture = textureLoader.load('/ruta.jpg');


    // Repetir las texturas para que cubran el plano de 50x50
    roadTexture.wrapS = roadTexture.wrapT = THREE.RepeatWrapping;
    grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
    rutaTexture.wrapS =  rutaTexture.wrapT = THREE.RepeatWrapping;

    roadTexture.repeat.set(1, 1);
    grassTexture.repeat.set(1, 1); // Pasto repetido varias veces
    rutaTexture.repeat.set(1, 1);
    // Crear geometría del plano
    const planeGeometry = new THREE.PlaneGeometry(50, 50);
    const planeMaterial = new THREE.MeshStandardMaterial({
        map: grassTexture, // Por defecto pasto
    });
    
    // Crear el mesh y girarlo para que sea el suelo
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2; // Girar 90 grados para que sea suelo
    plane.receiveShadow = true;
    scene.add(plane);
    
    // Agregar pisoen el centro usando otro plano
    const roadGeometry = new THREE.PlaneGeometry(10, 10); // 30 de ancho
    const roadMaterial = new THREE.MeshStandardMaterial({
        map: roadTexture
    });
    
    const road = new THREE.Mesh(roadGeometry, roadMaterial);
    road.rotation.x = -Math.PI / 2;
    
    road.position.set(-19,0,-20);
    road.position.y = 0.01; // Para evitar el z-fighting con el pasto
    scene.add(road);
    
           // Agregar ruta el centro usando otro plano
    const rutaGeometry = new THREE.PlaneGeometry(1, 50); // 50 de ancho
    const rutaMaterial = new THREE.MeshStandardMaterial({
        map: rutaTexture
    });
        
    const ruta= new THREE.Mesh(rutaGeometry, rutaMaterial);
    ruta.rotation.x = -Math.PI / 2;
        
    ruta.position.set(10,0.01,0);
    ruta.position.y = 0.01; // Para evitar el z-fighting con el pasto
    scene.add(ruta);


             // Agregar ruta2 el centro usando otro plano
  const ruta2Geometry = new THREE.PlaneGeometry(12, 1); // 
  const ruta2Material = new THREE.MeshStandardMaterial({
      map: rutaTexture
  });
      
  const ruta2= new THREE.Mesh(rutaGeometry, rutaMaterial);
  
  ruta2.rotation.x = -Math.PI / 2;
  ruta2.rotation.z = Math.PI / 2.3; // Rotar 45 grados hacia la izquierda
  ruta2.position.set(0,0.01,-15);
  ruta2.position.y = 0.001; // Para evitar el z-fighting con el pasto
  scene.add(ruta2);


       // Textura del camino
/* const rutaTexture = new THREE.TextureLoader().load('/ruta.jpg'); */
/* const rutaMaterial = new THREE.MeshBasicMaterial({ map: rutaTexture }); */

// Primer segmento del camino (horizontal)
/* const rutaGeometry1 = new THREE.PlaneGeometry(60, 10); */
/* const ruta1 = new THREE.Mesh(rutaGeometry1, rutaMaterial); */
/* ruta1.rotation.x = -Math.PI / 2; */
/* ruta1.position.set(-20, 0.01, -30); */
/* scene.add(ruta1); */
/*  */
// Segundo segmento del camino (vertical)
/* const rutaGeometry2 = new THREE.PlaneGeometry(1, 40); */
/* const ruta2 = new THREE.Mesh(rutaGeometry2, rutaMaterial); */
/* ruta2.rotation.x = -Math.PI / 2; */
/* ruta2.position.set(10, 0.01, -10); */
/* scene.add(ruta2); */
       
       
       
        const keys = {};
        window.addEventListener('keydown', (event) => (keys[event.key.toLowerCase()] = true));
        window.addEventListener('keyup', (event) => (keys[event.key.toLowerCase()] = false));

        const truckSpeed = 0.3;
        const rotationSpeed = 0.05;
        let followTruck = false;
        function moveTruck() {
          
           if (truck) {
             const newPosition = truck.position.clone(); // Copiamos la posición actual
         
             if (keys['s']) {
               newPosition.z -= Math.cos(truck.rotation.y) * truckSpeed;
               newPosition.x -= Math.sin(truck.rotation.y) * truckSpeed;
             }
             if (keys['w']) {
               newPosition.z += Math.cos(truck.rotation.y) * truckSpeed;
               newPosition.x += Math.sin(truck.rotation.y) * truckSpeed;
             }
             if (keys['a']) {
               truck.rotation.y += rotationSpeed;
             }
             if (keys['d']) {
               truck.rotation.y -= rotationSpeed;
             }

             /*  // Hacer que la cámara siga siempre al camion desde atrás */
             /*   const cameraOffset = new THREE.Vector3(0, 3, -8); // Cámara detrás y arriba  */
             /*   const rotatedOffset = cameraOffset.clone().applyMatrix4(new THREE.Matrix4().makeRotationY(truck.rotation.y));  */
             /*   const newCameraPos = truck.position.clone().add(rotatedOffset);  */
             /*   camera.position.lerp(newCameraPos, 0.1); // Movimiento suave  */
             /*   camera.lookAt(truck.position);  */
         
             // **Limitar el movimiento del camión dentro de (-50, 50) en X y Z**
             newPosition.x = THREE.MathUtils.clamp(newPosition.x, -25, 25);
             newPosition.z = THREE.MathUtils.clamp(newPosition.z, -25, 25);
             followTruck = true;
             // Aplicamos la posición limitada
             truck.position.copy(newPosition);
         
             // **Ajustar la cámara para que siga al camión**
             /* const offset = new THREE.Vector3(0, 3, -10); // Más alto y más lejos */
             /* const cameraPosition = offset.clone().applyMatrix4(truck.matrixWorld); */
             /* camera.position.lerp(cameraPosition, 0.1); */
             /* camera.lookAt(truck.position); */
              }
            }

    
        
        

        function createSmoke() {
          const smokeGeometry = new THREE.SphereGeometry(0.2, 8, 8);
          const smokeMaterial = new THREE.MeshBasicMaterial({
            color: 0x555555, // Gris oscuro
            transparent: true,
            opacity: 0.3
          });
          const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
          if (truck) {
            // Ajustar la dirección y posición del humo para que suba y esté más espaciado
            smoke.position.set(
              truck.position.x - Math.sin(truck.rotation.y),
              truck.position.y + .2,  // Más alto para que suba
              truck.position.z - Math.cos(truck.rotation.y)
            );
            scene.add(smoke);

            // Crear variación en el tamaño y color del humo
            const randomColor = Math.random() > 0.5 ? 0x888888 : 0x666666;
            smoke.material.color.set(randomColor);

            // Animar el humo para que suba y se disipe
            const smokeLifetime = 2000;  // Duración del humo
            const displacementSpeed = 0.02;  // Velocidad de ascenso del humo

            function animateSmoke() {
              smoke.position.y += displacementSpeed;  // Subir el humo
              smoke.material.opacity -= 0.001;  // Desvanecimiento gradual
              if (smoke.material.opacity <= 0) {
                scene.remove(smoke);  // Eliminar el humo cuando se desvanece
              } else {
                requestAnimationFrame(animateSmoke);
              }
            }
            animateSmoke();
          }
        }
        

        function animate() {
 
 
 
 
          moveTruck();
          if (truck && (keys['w'] || keys['s'])) {
            createSmoke();
            if (followTruck) {
               camera.position.set(truck.position.x + 0, 4, truck.position.z +  6);
               camera.lookAt(truck.position);
               scene.fog = new THREE.FogExp2( 0xcccccc, 0.023 );
           }
          }
          /* if (truck && (keys['a'] || keys['d'])) { */
          /*      createSmoke(); */
          /*      if (followTruck) { */
          /*       camera.position.set(truck.position.x + 0, 4, truck.position.z +  6) */;
          /*         camera.lookAt(ciudad2.position); */
          /*         scene.fog = new THREE.FogExp2( 0xcccccc, 0.023 ); */
          /*     }  */
          /*    } */
        /*   controls.update(); */
          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        
        }
      
        animate();
      }

      main();
    </script>

    
  </body>
</html>
